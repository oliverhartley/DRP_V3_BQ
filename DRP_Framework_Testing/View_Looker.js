/**
 * ****************************************
 * Google Apps Script - Looker View Generator
 * File: View_Looker.js
 * Description: Generates a flat, denormalized table designed specifically for Looker Studio ingestion.
 *              Joins CACHE_PROFILES (Fact) with CACHE_PARTNER_LANDSCAPE (Dimension).
 * ****************************************
 */

/**
 * Main execution function to build the Looker Data Source.
 */
function runLookerDataBuilder() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  
  // 1. Read Data Sources
  const landscapeSheet = ss.getSheetByName(SHEETS.CACHE_PARTNER_LANDSCAPE);
  const profilesSheet = ss.getSheetByName(SHEETS.CACHE_PROFILES);

  if (!landscapeSheet || !profilesSheet) {
    Logger.log("[Looker] Missing CACHE sheets. Run Landscape & Profiles rebuild first.");
    return;
  }

  const landscapeData = landscapeSheet.getDataRange().getValues();
  const profilesData = profilesSheet.getDataRange().getValues();

  // 2. Index Partner Landscape (Domain -> Metadata)
  // Header: Name(0), Domain(1), Managed(2), EmailTo(3), EmailCC(4), Countries(5+)...
  // We also want segment flags: GSI(21+0), MCO(21+1), PS(21+2), AI(40+... wait, need to check config offsets or raw index)
  // Let's rely on column names or Config mapping if possible, but Landscape is "Master View".
  // Actually, Landscape generated by Data_Update.js uses standard offsets.
  // Let's just grab the Boolean flags from the Landscape Schema if they exist there.
  // In `Data_Update.js` (rebuildPartnerCache), we see it writes:
  // Name, Domain, Managed, EmailTo, EmailCC, [Countries...], Is_GSI, Is_MCO, Is_PS, ...
  
  // Let's inspect the Header row of Landscape to dynamic map columns to be safe.
  const headersL = landscapeData[0];
  const colMapL = {};
  headersL.forEach((h, i) => colMapL[String(h).toLowerCase()] = i);

  const getCol = (row, name) => {
    const idx = colMapL[name.toLowerCase()];
    return (idx !== undefined) ? row[idx] : null;
  };

  const partnerMap = new Map();

  for (let i = 1; i < landscapeData.length; i++) {
    const row = landscapeData[i];
    const domain = String(row[1]).toLowerCase().trim();
    
    if (domain) {
      partnerMap.set(domain, row); // Store entire row for flexible access
    }
  }

  // 3. Process Profiles & Flatten
  // Output Schema for Looker:
  // Partner Name, Domain, Managed, Country, Region?, Job, Solution, Product, Profile ID, Score, Tier, 
  // Is GSI, Is MCO, Is PS, Is Security, Is GenAI, Email To
  
  const outputRows = [];
  
  for (let i = 1; i < profilesData.length; i++) {
    const row = profilesData[i];
    const pDomain = String(row[1]).toLowerCase().trim();
    
    // Join with Landscape
    const metaRow = partnerMap.get(pDomain);
    
    // If partner not in Landscape (rare, but possible if cache desync), skip or keep?
    // Keep for data integrity, fill nulls.
    
    const pName = row[0];
    // pDomain
    const pProfileId = row[2];
    const pCountry = row[3];
    const pJob = row[4];
    const pProduct = row[5];
    const pScore = Number(row[6]) || 0;
    const pSolution = row[7];
    
    if (!pProduct || !pSolution) continue;

    // Calculate Tier
    let tier = 'Tier 4';
    if (pScore >= 50) tier = 'Tier 1';
    else if (pScore >= 35) tier = 'Tier 2';
    else if (pScore >= 20) tier = 'Tier 3';

    // Metadata
    let isManaged = false;
    let emailTo = "";
    let isGsi = false;
    let isMco = false;
    let isPs = false;
    let isSecurity = false;
    let isAi = false;

    if (metaRow) {
      isManaged = metaRow[2]; // Fixed index for core fields or use map
      emailTo = metaRow[3];
      
      // Dynamic boolean checks based on headers usually found in Landscape
      // Assuming standard names: "is_gsi", "is_mco", etc. or "GSI", "MCO"
      isGsi = Boolean(getCol(metaRow, "is_gsi") || getCol(metaRow, "gsi"));
      isMco = Boolean(getCol(metaRow, "is_mco") || getCol(metaRow, "mco"));
      isPs  = Boolean(getCol(metaRow, "is_ps")  || getCol(metaRow, "ps"));
      isSecurity = Boolean(getCol(metaRow, "is_security") || getCol(metaRow, "security"));
      isAi = Boolean(getCol(metaRow, "is_ai_ml") || getCol(metaRow, "ai/ml") || getCol(metaRow, "genai"));
    }

    outputRows.push([
      pName,
      pDomain,
      pCountry,
      isManaged,
      pSolution,
      pProduct,
      tier,
      pScore,
      pJob, // Job Title
      pProfileId,
      isGsi,
      isMco,
      isPs,
      isSecurity,
      isAi,
      emailTo
    ]);
  }

  // 4. Write to VIEW_Looker_Data
  const lookerSheetName = "VIEW_Looker_Data";
  let lookerSheet = ss.getSheetByName(lookerSheetName);
  
  if (!lookerSheet) {
    lookerSheet = ss.insertSheet(lookerSheetName);
    lookerSheet.setTabColor("4285F4"); // Google Blue
  }
  
  lookerSheet.clear();
  
  const headers = [
    "Partner Name", "Domain", "Country", "Is Managed", "Solution", "Product", "Tier", "Score", 
    "Job Title", "Profile ID", 
    "Is GSI", "Is MCO", "Is PS", "Is Security", "Is AI/ML", "Email Contact"
  ];
  
  if (outputRows.length > 0) {
    lookerSheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight("bold");
    lookerSheet.getRange(2, 1, outputRows.length, headers.length).setValues(outputRows);
    
    // Formatting
    // lookerSheet.getRange(2, 8, outputRows.length, 1).setNumberFormat("0"); // Score
  }
  
  Logger.log(`[Looker] Generated ${outputRows.length} rows for Looker Studio.`);
}
